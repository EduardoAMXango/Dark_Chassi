import numpy as np
from copy import deepcopy
from concurrent.futures import ProcessPoolExecutor, as_completed
import itertools
import traceback
from Estrutura_Tipada import Estrutura
import matplotlib.pyplot as plt

class ChassisDEOptimizer:
    def __init__(
        self,
        mandatory_bases: np.ndarray,
        mandatory_connections: list = None,
        pop_size: int = 50,
        F: float = 0.5,
        CR: float = 0.9,
        max_generations: int = 200,
        k_neighbors: int = 3
    ):
        """
        Parâmetros:
        - mandatory_bases: array de forma (21, 3), coordenadas dos 21 nós de um lado.
        - mandatory_connections: lista de tuplas (i, j) que representam conexões obrigatórias
          entre nós (índices referenciando mandatory_bases).
        - pop_size, F, CR, max_generations, k_neighbors: parâmetros de DE.
        """

        # 1) Nós obrigatórios e número de nós
        self.mandatory_orig = mandatory_bases.copy()
        self.num_mandatory = self.mandatory_orig.shape[0]
        self.mandatory_connections = mandatory_connections or []
        self.k = k_neighbors

        # 2) Parâmetros de DE
        self.pop_size = pop_size
        self.F = F
        self.CR = CR
        self.max_gens = max_generations

        # 3) Número máximo de nós (incluindo simetria): 
        #    Pode variar de 21 (todos centrais) a 42 (nenhum central)
        self.max_nodes = 2 * self.num_mandatory
        # 4) Número máximo de arestas possíveis via k-vizinhos
        self.max_edges = int(self.max_nodes * self.k / 2)

        # 5) Dimensões do genótipo
        self.dim_mand = self.num_mandatory * 3
        self.dim_tube = self.max_edges
        self.dim_total = self.dim_mand + self.dim_tube

        # 6) Perfis de tubo possíveis
        self.tube_profiles = ['Tubo A', 'Tubo B', 'Tubo C', 'Tubo D']

    def reflect_nodes(self, nodes: np.ndarray) -> np.ndarray:
        """Espelha um conjunto de nós em X→−X (simetria em Y)."""
        mirrored = nodes.copy()
        mirrored[:, 0] *= -1.0
        return mirrored

    def random_point_in_ball(self, radius: float, size: int):
        """
        Gera `size` pontos 3D uniformemente dentro de uma bola de raio `radius`.
        Retorna array shape=(size,3).
        """
        x = np.random.normal(size=(size, 3))
        norm = np.linalg.norm(x, axis=1, keepdims=True)
        direction = x / norm
        r = np.random.rand(size, 1) ** (1/3) * radius
        return direction * r

    def enforce_mandatory_bounds(self, mand_coords: np.ndarray) -> np.ndarray:
        """
        Garante que cada mand_coords[i] fique dentro da esfera
        de raio 0.05 em torno de self.mandatory_orig[i].
        """
        orig = self.mandatory_orig
        delta = mand_coords - orig
        norms = np.linalg.norm(delta, axis=1, keepdims=True)
        mask = (norms > 0.05)

        delta_proj = (delta / norms) * 0.05
        mand_coords_adjusted = mand_coords.copy()
        mand_coords_adjusted[mask.flatten()] = (orig + delta_proj)[mask.flatten()]
        return mand_coords_adjusted

    def validate_min_distance(self, coords, min_dist=0.05):
        dists = np.linalg.norm(coords[:, None, :] - coords[None, :, :], axis=2)
        np.fill_diagonal(dists, np.inf)
        return np.all(dists >= min_dist)

    def decode_full_individual(self, x: np.ndarray):
        try:
            # 1. Processamento dos nós mandatórios
            mand_coords = x[:self.dim_mand].reshape((self.num_mandatory, 3))
            mand_coords = self.enforce_mandatory_bounds(mand_coords)

            full_list = []
            node_types = {}

            for i, coord in enumerate(mand_coords):
                x_val = coord[0]
                if abs(x_val) < 1e-6:
                    idx = len(full_list)
                    full_list.append(coord.tolist())
                    node_types[i] = ('central', idx)
                else:
                    if x_val < 0:
                        coord[0] = -x_val
                    idx_right = len(full_list)
                    full_list.append(coord.tolist())
                    mirrored = coord.copy()
                    mirrored[0] *= -1
                    idx_left = len(full_list)
                    full_list.append(mirrored.tolist())
                    node_types[i] = ('lateral', (idx_right, idx_left))

            nodes = np.array(full_list)
            num_nodes = len(nodes)

            # 2. Criação das conexões
            elements = []
            used_edges = set()

            # Conexões obrigatórias
            for (i, j) in self.mandatory_connections:
                if i not in node_types or j not in node_types:
                    continue
                type_i, ids_i = node_types[i]
                type_j, ids_j = node_types[j]
                
                if type_i == 'central' and type_j == 'central':
                    elements.append((ids_i, ids_j, 'Tubo A'))
                elif type_i == 'lateral' and type_j == 'lateral':
                    elements.append((ids_i[0], ids_j[0], 'Tubo A'))
                    elements.append((ids_i[1], ids_j[1], 'Tubo A'))
                else:
                    if type_i == 'central':
                        central_idx = ids_i
                        lateral_idx = ids_j
                    else:
                        central_idx = ids_j
                        lateral_idx = ids_i
                    elements.append((central_idx, lateral_idx[0], 'Tubo A'))
                    elements.append((central_idx, lateral_idx[1], 'Tubo A'))

            # Conexões por k-vizinhos
            if num_nodes > 1:
                dist_matrix = np.linalg.norm(
                    nodes[:, np.newaxis, :] - nodes[np.newaxis, :, :], 
                    axis=2
                )
                np.fill_diagonal(dist_matrix, np.inf)
                
                for i in range(num_nodes):
                    nearest = np.argsort(dist_matrix[i])[:self.k]
                    for j in nearest:
                        edge = (min(i, j), max(i, j))
                        if edge not in used_edges:
                            used_edges.add(edge)
                            elements.append((i, j, None))

            # Atribuição de perfis de tubo
            tube_vars = x[self.dim_mand:self.dim_total]
            for idx, (i, j, profile) in enumerate(elements):
                if profile is None:
                    if idx < len(tube_vars):
                        tval = tube_vars[idx]
                        t_int = int(np.clip(tval, 0, 3.999))
                        elements[idx] = (i, j, self.tube_profiles[t_int])
                    else:
                        elements[idx] = (i, j, self.tube_profiles[0])

            return nodes, elements

        except Exception as e:
            print(f"[ERRO] decode_full_individual: {e}")
            traceback.print_exc()
            raise  
    
    def initialize_individual(self) -> np.ndarray:
        while True:
            # Gera deslocamentos aleatórios dentro da bola de raio 0.05
            deltas = self.random_point_in_ball(0.05, self.num_mandatory)
            mand_shifted = self.mandatory_orig + deltas
            
            # Decodifica para verificar as restrições
            test_genome = np.concatenate([mand_shifted.reshape(-1), np.zeros(self.dim_tube)])
            nodes, _ = self.decode_full_individual(test_genome)
            #print(nodes)
            # Verifica a distância mínima
            if self.validate_min_distance(nodes):
                # Se válido, gera os parâmetros de tubo e retorna
                tube_flat = np.random.uniform(0.0, 4.0, size=(self.max_edges,))
                return np.concatenate([mand_shifted.reshape(-1), tube_flat])
            
    def initialize_population(self):
        print("População Iniciada")
        pop = np.zeros((self.pop_size, self.dim_total))
        fitness = np.zeros(self.pop_size)

        for i in range(self.pop_size):
            while True:
                indiv = self.initialize_individual()
                break
            pop[i, :] = indiv
            fitness[i] = self.evaluate(indiv)
        print("População Criada")
        return pop, fitness

    def evaluate(self, x: np.ndarray) -> float:
        """
        Avalia o indivíduo x.
        1) Penaliza nós com grau < 3.
        2) Penaliza estrutura parcialmente desconectada.
        3) Monta e analisa estrutura via classe Estrutura.
        4) Penaliza rigidez, tensões e massa.
        """
        #print("Avaliação Iniciada" ,end="\r")
        nodes, elements = self.decode_full_individual(x)
        # 1) Se qualquer mandatório estiver fora da esfera 0.05, reject (mas apply_bounds já corrige)
        mand_coords = x[: self.dim_mand].reshape(self.num_mandatory, 3)
        mand_proj = self.enforce_mandatory_bounds(mand_coords)
        cost=0
        if not np.allclose(mand_coords.reshape(-1), mand_proj.reshape(-1)):
            return float('inf')

        # 2) Verifica distância mínima 0.15
        if not self.validate_min_distance(nodes, 0.05):
            return float('inf')
        
        estrutura = Estrutura(elements, nodes)
        estrutura.matrizes_global()

        fixed_dofs = [0 * 6 + i for i in range(6)]
        F_global = np.zeros(estrutura.num_dofs)
        F_global[0 * 6 + 0] = 300.0
        F_global[0 * 6 + 2] = 300.0

        deslocamentos = estrutura.static_analysis(F_global, fixed_dofs)
        stresses = estrutura.compute_stress(
            estrutura.compute_strain(deslocamentos),
            210e9, 0.27
        )
        von_mises = estrutura.compute_von_mises(stresses)
        massa = estrutura.mass()

        _, _, _, _, _, KT, KF, _, _ = estrutura.shape_fun()

        cost += penalidade_chassi(KT, KF, massa, von_mises)
        return cost
    
    def mutate_and_crossover(self, target_idx: int, pop: np.ndarray) -> np.ndarray:
        idxs = list(range(self.pop_size))
        idxs.remove(target_idx)
        a, b, c = np.random.choice(idxs, size=3, replace=False)

        x_i = pop[target_idx]
        x_a, x_b, x_c = pop[a], pop[b], pop[c]

        # DE/rand/1 mutation
        v = x_a + self.F * (x_b - x_c)

        # Binomial crossover
        u_candidate = np.empty_like(x_i)
        j_rand = np.random.randint(self.dim_total)
        for j in range(self.dim_total):
            if np.random.rand() < self.CR or j == j_rand:
                u_candidate[j] = v[j]
            else:
                u_candidate[j] = x_i[j]

        u = self.apply_bounds(u_candidate)

        # VALIDAÇÃO DIRETA DAS RESTRIÇÕES DURANTE A CRIAÇÃO
        nodes_u, _ = self.decode_full_individual(u)
        if not self.validate_min_distance(nodes_u):
            return x_i.copy()
        return u

    def apply_bounds(self, u: np.ndarray) -> np.ndarray:
        # Aplica limites aos nós mandatórios
        mand_try = u[: self.dim_mand].reshape(self.num_mandatory, 3)
        mand_try = self.enforce_mandatory_bounds(mand_try)
        mand_try_flat = mand_try.reshape(-1)

        # Aplica limites aos tubos
        tube_try = u[self.dim_mand :]
        tube_try = np.clip(tube_try, 0.0, 3.999)

        return np.concatenate([mand_try_flat, tube_try])

    def plotar(self, individuo):
        nodes, elements = individuo
        fig = plt.figure(figsize=(10, 6))
        ax = fig.add_subplot(111, projection='3d')

        num_nodes = len(nodes)
        elements_valid = [(i, j, t) for i, j, t in elements if 0 <= i < num_nodes and 0 <= j < num_nodes]

        xs, ys, zs = zip(*nodes)
        ax.scatter(ys, xs, zs, s=25, c='black')
        for i, j, t in elements_valid:
            ni, nj = nodes[i], nodes[j]
            ax.plot([ni[1], nj[1]], [ni[0], nj[0]], [ni[2], nj[2]], 'b-')
        ax.set_xlabel('Y')
        ax.set_ylabel('X')
        ax.set_zlabel('Z')
        ax.set_box_aspect([3,1,2])
        plt.title("Chassi Evoluído")
        plt.show()

    def optimize(self):
        print("Otimização Iniciada")
        pop, fitness = self.initialize_population()
        
        for gen in range(self.max_gens):
            trial_vectors = [None] * self.pop_size
            trial_fitness = [None] * self.pop_size

            for i in range(self.pop_size):
                u = self.mutate_and_crossover(i, pop)
                f = self.evaluate(u)
                trial_vectors[i] = u
                trial_fitness[i] = f

            # Atualização da população
            for i in range(self.pop_size):
                if trial_fitness[i] <= fitness[i]:
                    pop[i, :] = trial_vectors[i]
                    fitness[i] = trial_fitness[i]

            best_idx = np.argmin(fitness)
            print(f"Geração {gen+1:03d} | melhor fitness = {fitness[best_idx]:.4e}",end="\r")

        best_idx = np.argmin(fitness)
        best_vec = pop[best_idx]
        best_nodes, best_elements = self.decode_full_individual(best_vec)
        return (best_nodes, best_elements), fitness[best_idx]
    
def penalidade_chassi(KT, KF, massa, tensoes):
    # Limites e parâmetros
    KT_min = 1e7          # Rigidez torcional mínima (N·m/rad)
    KF_min = 1e6          # Rigidez flexão mínima (N/m)
    massa_ideal = 23       # Massa alvo (kg)
    K_mola = 5e5           # Constante da mola do amortecedor (N/m)
    tensao_adm = 250e6     # Tensão admissível do material (Pa)
    alpha = 0.5            # Fator de sensibilidade exponencial
    beta = 10              # Fator de escala logarítmica
    
    penalidade_total = 0

    # 1. Rigidez Torcional (Função Exponencial)
    if KT < KT_min:
        deficit = (KT_min - KT) / KT_min
        # Penalidade cresce exponencialmente com o déficit
        penalidade_total += np.exp(alpha * deficit) - 1

    # 2. Rigidez em Flexão (Função Logarítmica)
    if KF < KF_min:
        deficit = (KF_min - KF) / KF_min
        # Penalidade logarítmica: suave para pequenas violações, forte para grandes
        penalidade_total += beta * np.log(1 + deficit)

    # 3. Massa (Função Híbrida)
    if massa > massa_ideal:
        excesso = (massa - massa_ideal) / massa_ideal
        # Combina resposta linear inicial com crescimento exponencial
        penalidade_total += excesso + np.exp(alpha * excesso) - 1

    # 4. Compatibilidade com Mola (Lógica Aprimorada)
    ratio_KT = K_mola / KT if KT > 0 else float('inf')
    ratio_KF = K_mola / KF if KF > 0 else float('inf')
    
    if ratio_KT > 25 or ratio_KF > 25:
        # Penalidade proporcional ao nível de incompatibilidade
        violacao = max(ratio_KT/25, ratio_KF/25) - 1
        penalidade_total += 100 * violacao**2

    # 5. Tensões (Abordagem Baseada em Risco)
    tensao_max = max(tensoes)
    if tensao_max > tensao_adm:
        # Penalidade exponencial para tensões acima do admissível
        excesso = (tensao_max - tensao_adm) / tensao_adm
        penalidade_total += np.exp(5 * excesso) - 1
    
    # Penalidade por distribuição desigual de tensões (logarítmica)
    razao_tensoes = np.ptp(tensoes) / np.mean(tensoes) if np.mean(tensoes) > 0 else 0
    penalidade_total += np.log(1 + razao_tensoes)

    return penalidade_total * 100  # Fator de escala global

if __name__ == "__main__":
    mandatory_bases = np.array([
        [0.32, 1.92, 0.00],
        [0.32, 1.92, 0.48],
        [0.32, 1.77, 0.21],
        [0.32, 1.92, 0.09],
        [0.32, 1.50, 0.03],
        [0.24, 1.14, 0.03],
        [0.32, 1.14, 0.09],
        [0.32, 1.14, 0.36],
        [0.28, 1.14, 0.72],
        [0.00, 1.14, 0.78],
        [0.32, 0.63, 0.54],
        [0.28, 0.33, 0.66],
        [0.28, 0.57, 1.20],
        [0.00, 0.54, 1.35],
        [0.32, 0.69, 0.24],
        [0.32, 0.69, 0.00],
        [0.32, 0.45, 0.21],
        [0.32, 0.24, 0.09],
        [0.16, 0.00, 0.21],
        [0.16, 0.00, 0.09],
        [0.16, 0.00, 0.42]
    ])
    mandatory_connections = [
    (0, 1,), 
    (0, 3), 
    (1, 3), 
    (2, 0), 
    (2, 1), 
    (2, 4), 
    (3, 4), 
    (4, 5),  
    (5, 6),   
    (6, 7),   
    (7, 8),   
    (8, 10),  
    (10, 11), 
    (11, 12), 
    (12, 13), 
    (14, 10), 
    (14, 15), 
    (15, 16), 
    (16, 17), 
    (17, 18), 
    (17, 19), 
    (18, 19), 
    (18, 20), 
    (19, 20)   
            ]
    
    otimizador = ChassisDEOptimizer(
        mandatory_bases=mandatory_bases,
        mandatory_connections=mandatory_connections,
        pop_size=30,
        F=0.6,
        CR=0.8,
        max_generations=200,
        k_neighbors=4
    )

    best_indiv, best_cost = otimizador.optimize()
    print(f"\nMelhor custo: {best_cost:.6e}")
    nodes_final, elements_final = best_indiv

    # Plota chassi final
    otimizador.plotar(best_indiv)
