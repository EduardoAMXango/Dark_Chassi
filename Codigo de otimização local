import numpy as np
import matplotlib.pyplot as plt
from estrutura_main import Estrutura
import random

class ChassiDE:
    def __init__(self, n_nodes=50, pop_size=100, ngen=100, F=0.8, CR=0.7, min_dist=0.15,max_dist=0.7):
        self.N_NODES = n_nodes
        self.POP_SIZE = pop_size
        self.NGEN = ngen
        self.F = F
        self.CR = CR
        self.MIN_DIST = min_dist
        self.MAX_DIST = max_dist
        self.MAX_X, self.MAX_Y, self.MAX_Z = 0.6, 2.0, 1.0
        self.population = [self.criar_individuo_simetrico() for _ in range(pop_size)]

    def criar_individuo_simetrico(self):
        nodes = []
        half = self.N_NODES // 2
        for _ in range(half):
            zona = random.choices(["dianteira", "cockpit", "traseira"], weights=[1, 2, 1])[0]
            y = random.uniform(*{"dianteira": (0.0, 0.5), "cockpit": (0.5, 1.5), "traseira": (1.5, 2.0)}[zona])
            x = random.uniform(0.1, self.MAX_X)
            z = random.uniform(-0.1, self.MAX_Z)
            nodes.append([x, y, z])
            nodes.append([-x, y, z])
        
        elements = []
        for i in range(0, len(nodes), 2):
            elements.append((i+1, i+2))
            if i+4 < len(nodes):
                elements.append((i+1, i+5))
                elements.append((i+2, i+6))
        
        return [nodes, elements]

    def mutacao(self, base, a, b, c):
        base_nodes = np.array(base[0])
        a_nodes = np.array(a[0])
        b_nodes = np.array(b[0])
        c_nodes = np.array(c[0])
        mutant_nodes = base_nodes + self.F * (a_nodes - b_nodes + c_nodes - base_nodes)
        
        # Clipping e simetria
        new_nodes = []
        for i in range(0, len(mutant_nodes), 2):
            x, y, z = mutant_nodes[i]
            x = np.clip(x, 0.1, self.MAX_X)
            y = np.clip(y, 0.0, self.MAX_Y)
            z = np.clip(z, -0.3, self.MAX_Z)
            new_nodes.append([x, y, z])
            new_nodes.append([-x, y, z])
        return [new_nodes, base[1]]

    def recombinacao(self, target, mutant):
        trial_nodes = []
        for (t, m) in zip(target[0], mutant[0]):
            if random.random() < self.CR:
                trial_nodes.append(m)
            else:
                trial_nodes.append(t)
        return [trial_nodes, target[1]]

    def avaliar(self, individuo):
        try:
            nodes, elements = individuo
            estrutura = Estrutura(elements, nodes)
            estrutura.matrizes_global()
            _, _, freq = estrutura.modal_analysis()

            F_global = np.zeros(estrutura.num_dofs)
            F_global[6*4 + 1] = 3000
            F_global[6*5 + 1] = 3000
            deslocamentos = estrutura.static_analysis(F_global)
            stresses = estrutura.compute_stress(estrutura.compute_strain2(deslocamentos), 210e9, 0.27)
            von_mises = estrutura.compute_von_mises(stresses)

            massa = sum(estrutura.calcular_comprimento(e) * 7850 * 0.0125 for e in elements)
            tensao_max = np.max(von_mises)

            penalidade = 0
            for i in range(0, len(nodes), 2):
                n1, n2 = nodes[i], nodes[i+1]
                if not (np.isclose(n1[0], -n2[0], atol=0.05) and np.isclose(n1[1:], n2[1:], atol=0.05).all()):
                    penalidade += 1e4

            y_coords = [n[1] for n in nodes]
            if max(y_coords) - min(y_coords) < 2.0:
                penalidade += 1e5

            conexoes_por_no = [0] * len(nodes)
            for i, j in elements:
                if i-1 < len(nodes) and j-1 < len(nodes):
                    conexoes_por_no[i-1] += 1
                    conexoes_por_no[j-1] += 1
                    dist = np.linalg.norm(np.array(nodes[i-1]) - np.array(nodes[j-1]))
                    if dist < self.MIN_DIST:
                        penalidade += 1e4
                    if dist > self.MAX_DIST:  # penalidade para comprimento excessivo
                        penalidade += 1e4

            for count in conexoes_por_no:
                if count < 2:
                    penalidade += 5e5

            return massa + penalidade, freq[0], tensao_max

        except:
            return 1e9, 0, 1e9

    def evoluir(self):
        for gen in range(self.NGEN):
            nova_pop = []
            for i, target in enumerate(self.population):
                indices = list(range(self.POP_SIZE))
                indices.remove(i)
                a, b, c = random.sample([self.population[j] for j in indices], 3)

                mutant = self.mutacao(target, a, b, c)
                trial = self.recombinacao(target, mutant)

                f_target = self.avaliar(target)
                f_trial = self.avaliar(trial)

                if f_trial[0] < f_target[0]:
                    nova_pop.append(trial)
                else:
                    nova_pop.append(target)

            self.population = nova_pop
            melhor = min(self.population, key=lambda ind: self.avaliar(ind)[0])
            print(f"Geração {gen+1}: melhor massa = {self.avaliar(melhor)[0]:.1f}", end="\r")

        return melhor

    def plotar(self, individuo):
        nodes, elements = individuo
        fig = plt.figure(figsize=(10, 6))
        ax = fig.add_subplot(111, projection='3d')
        x, y, z = [n[0] for n in nodes], [n[1] for n in nodes], [n[2] for n in nodes]
        ax.scatter(y, x, z, c='r', s=50)
        for i, j in elements:
            if i-1 < len(nodes) and j-1 < len(nodes):
                ni, nj = nodes[i-1], nodes[j-1]
                ax.plot([ni[1], nj[1]], [ni[0], nj[0]], [ni[2], nj[2]], 'b-')
        ax.set_xlabel('Y'); ax.set_ylabel('X'); ax.set_zlabel('Z')
        plt.title("Chassi Evoluído (DE)")
        plt.show()
if __name__ == "__main__":
    chassi = ChassiDE()
    melhor_ind = chassi.evoluir()
    chassi.plotar(melhor_ind)

    m, f, t = chassi.avaliar(melhor_ind)
    print(f"\nMelhor solução:")
    print(f"- Massa: {m:.1f} kg")
    print(f"- Frequência fundamental: {f:.1f} Hz")
    print(f"- Tensão máxima: {t/1e6:.1f} MPa")
